/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\defgroup wifi_requirements Requirements
\ingroup dv_wifi

The WiFi driver validation requires the following hardware:
- WiFi Access Point connected to the local network
- \ref sockserver_pc "PC running Microsoft Windows"

The WiFi driver validation requires the following software:
- \ref wifi_sock_setup "SockServer" application running in the same network as WiFi Access Point used for testing
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\defgroup wifi_config Configuration
\ingroup dv_wifi

The WiFi driver validation settings are available in the **DV_WiFi_Config.h** configuration file.

Some settings depend on the test environment and need to be changed for proper operation of the WiFi driver validation.<br>
These settings can be found under **Configuration** settings in the **DV_WiFi_Config.h** configuration file and need to 
be set as follows:

\image html dv_wifi_config_h.png "DV_WiFi_Config.h configuration file in Configuration Wizard view mode"

<b>Station</b> related settings needed for WiFi module to connect to the WiFi Access Point in the local network:
- SSID
- Password
- Security Type
- Channel: use 0 for auto-detect channel
- WPS PIN: PIN used for WPS tests (the Access Point has to have the same PIN enabled and WPS service running)

<b>Access Point</b> related settings needed for testing Access Point functionality (network creation) of the WiFi module:
- SSID
- Password
- Security Type
- Channel: use 0 for auto-detect channel
- WPS PIN: PIN used for WPS tests (auxiliary station has to have the same PIN enabled)

<b>Socket</b> related setting needed for Socket API and Socket Operation tests:
- SockServer IP: IP address assigned to the SockServer on your local network
- Number of sockets: Number of sockets that the driver supports and that will be tested

\note IP address is displayed by the SockServer application (on the embedded board's LCD when using embedded SockServer).

Under **Tests** select testing functionality as required.
For details on tests performed by each test function please refer to \ref wifi_tests "WiFi Tests".

<b>Control</b>, **Management** and **Socket API (requires SockServer)** group of tests enable or disable 
WiFi Driver API function tests respectively.

<b>Management (requires user interaction)</b> and **Socket Operation (requires SockServer)** group of tests 
are used for more complex operational test of the WiFi driver.<br>
A brief description of each test functionality can be viewed by using 
<a href="https://developer.arm.com/documentation/101407/0537/Utilities/Configuration-Wizard" target="_blank">Configuration Wizard</a>
view of the **DV_WiFi_Config.h** file and clicking on the test or hovering a mouse pointer over it.

*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\defgroup wifi_sock_setup SockServer 
\ingroup dv_wifi

The \b SockServer is an application providing a set of services used by the WiFi CMSIS-Driver Validation suite to test the
Socket interface of the WiFi driver. It is located in the **`<pack installation root>/Tools/SockServer`** subdirectory of the pack root directory.
The SockServer is available for different target systems. It runs several standard network services.

The **SockServer** is available for **Personal Computer** running Microsoft Windows (executable located in **`<pack installation root>/Tools/SockServer/PC/Win`**).

The following services are available by SockServer:
- \b Echo service on port \token{7}, TCP and UDP
  \n (two instances of TCP service, one instance of UDP service)
- \b Discard service on port \token{9}, TCP and UDP
  \n (one instance of TCP service, one instance of UDP service)
- \b Chargen service on port \token{19}, TCP and UDP
  \n (two instances of TCP service, one instance of UDP service)
- \b Assistant service on port \token{5000}
  \n (helper service used to test WiFi sockets in server mode (socket accept functionality))
- \b Telnet service on port \token{23}
  \n (SockServer status monitoring service)

\section sockserver_pc SockServer for PC running Microsoft Windows

\b Requirements:
 - Personal Computer running Microsoft Windows
 - PC connection to local network

SockServer is already built and can be executed by running the **SockServer.exe** file in **`<pack installation root>/Tools/SockServer/PC/Win`**.

If you need to change the functionality of SockServer, source files and a batch script for building the executable are
available in **`<pack installation root>/Tools/SockServer/PC/Win`**.

\note
- SockServer build process requires Minimalist GNU for Windows (MinGW).
- To build the SockServer executable for Windows, follow these steps:
  - Download and install MinGW from https://winlibs.com/
  - Set environment path in Microsoft Windows as explained under Usage heading on https://winlibs.com/#usage
  - Run **Build.bat** located in **`<pack installation root>/Tools/SockServer/PC/Win`** which will result in an executable that is located
    in **`<pack installation root>/Tools/SockServer/PC/Win`**

\subsection sockserver_pc_win_troubleshooting Troubleshooting

Problems and solutions:
 1. SockServer not responding to requests
    - Open Windows firewall -> Advanced settings
      - select inbound rules
    - create a new custom rule (New Rule...)
      - Rule type:     Program
      - Program:       This program path (select path to SockServer.exe)
      - Action:        Allow the connection
      - Profile:       Domain, Private (Public not advised)
      - Name:          SockServer  
 2. Test computer not responding to ping
    - Open Windows firewall -> Advanced settings
      - select inbound rules, enable rule
        File and Printer sharing (Echo request - ICMPv4-In)
      
    - If rule does not exist, create a new custom rule (New Rule...)
      - Rule type:     Custom
      - Program:       All programs
      - Protocol type: ICMPv4
      - ICMP Settings: Customize - Specific ICMP types: Echo Request
      - Scope:         Any IP address
      - Action:        Allow the connection
      - Profile:       Domain, Private (Public not advised)
      - Name:          Ping Echo  

*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\defgroup wifi_sock_testing Socket testing
\ingroup dv_wifi

Due to limitations of WiFi modules and their Software Development Kits (SDK), often it is not possible to comply with
CMSIS-Driver BSD rules regarding function behavior or function return codes. Hence, the WiFi Driver tests accept alternative
error codes and report them as Warnings and considers certain error codes as acceptable for certain functions.
Exceptions to BSD-strict error codes and functionality are written below: 

WiFi socket deviations from the BSD-strict specification
========================================================

-# \b SocketBind
 - bind socket to same address again<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_EINVAL<br>non BSD-strict accepted return codes: \token{0} or \token{ARM_SOCKET_ERROR}

 - bind another socket to used address<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_EADDRINUSE<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

 - bind on closed socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ESOCK<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

-# \b SocketListen
 - listen on already listening socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_EINVAL<br>non BSD-strict accepted return codes: \token{0} or \token{ARM_SOCKET_ERROR}

 - listen on unbound socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_EINVAL<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

 - listen on closed socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ESOCK<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

 - listen on datagram socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ENOTSUP<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

-# \b SocketAccept
 - receive on disconnected socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ECONNRESET<br>non BSD-strict accepted return codes: \token{ARM_SOCKET_EAGAIN} or \token{ARM_SOCKET_ERROR}

 - accept on closed socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ESOCK<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

 - listen on datagram socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ENOTSUP<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

 - accept on datagram socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ENOTSUP<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

-# \b SocketConnect
 - connect socket to same address again<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_EISCONN<br>non BSD-strict accepted return codes: \token{0} or \token{ARM_SOCKET_ERROR}

 - bind on connected socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_EISCONN<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

 - connect on closed socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ESOCK<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

 - connect to non-existent port<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ECONNREFUSED<br>non BSD-strict accepted return codes: \token{ARM_SOCKET_ETIMEDOUT} or \token{ARM_SOCKET_ERROR}

 - connect to non-existent stream server<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ETIMEDOUT<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

 - connect on listening socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_EINVAL<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

 - connect datagram socket to unspecified address (0.0.0.0)<br>
   <b>BSD-strict</b> expected return code \b 0<br>non BSD-strict accepted return codes: \token{ARM_SOCKET_EINVAL} or \token{ARM_SOCKET_ERROR}
   (special case that deletes the socket destination & filtering address)

-# \b SocketRecv
 - recv on closed socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ESOCK<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

 - recv on created socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ENOTCONN<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

 - recv on bound socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ENOTCONN<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

 - recv on listening socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ENOTCONN<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

-# \b SocketRecvFrom
 - recvfrom on closed socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ESOCK<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

-# \b SocketSend
 - send on closed socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ESOCK<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

 - send on disconnected socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ECONNRESET<br>non BSD-strict accepted return codes: >\token{0} or \token{ARM_SOCKET_EAGAIN} or \token{ARM_SOCKET_ERROR}

 - send on created socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ENOTCONN<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

 - send on bound socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ENOTCONN<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

 - send on listening socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ENOTCONN<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

 - send on closed socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ESOCK<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

-# \b SocketSendTo
 - sendto on closed socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ESOCK<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

-# \b SocketGetSockName
 - getsockname on closed socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ESOCK<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

 - getsockname on unbound socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_EINVAL<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

-# \b SocketGetPeerName
 - getpeername on closed socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ESOCK<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

 - getpeername on created socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ENOTCONN<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

 - getpeername on bound socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ENOTCONN<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

 - getpeername on listening socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ENOTCONN<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

-# \b SocketGetOpt
 - getsockopt on closed socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ESOCK<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

-# \b SocketSetOpt
 - setsockopt on closed socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ESOCK<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

-# \b SocketClose
 - close already closed socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ESOCK<br>non BSD-strict accepted return code \token{0}

-# \b SocketGetHostByName
 - gethostbyname for non-existing host<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_EHOSTNOTFOUND<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}
*/
