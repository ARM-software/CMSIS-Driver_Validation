/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\defgroup wifi_sock_setup WiFi SockServer 
\ingroup wifi_funcs

The \b SockServer is an application providing a set of services that the WiFi CMSIS-Driver Validation uses to test the Socket 
interface of the WiFi driver and is located in the <b>.\\Tools\\SockServer</b> subdirectory of the pack root directory.
The SockServer is available for different target systems and runs several standard network services.

The SockServer is available for following target systems:
 - <b>Personal Computer</b> running Microsoft Windows (executable located in <b>.\\Tools\\SockServer\\PC\\Win</b>)
 - Embedded <b>Keil MCB4300</b> evaluation board (uVision project located in <b>.\\Tools\\SockServer\\Embedded\\MDK\\Board\\MCB4300</b>)
 - Embedded <b>Keil MCBSTM32F400</b> evaluation board (uVision project located in <b>.\\Tools\\SockServer\\Embedded\\MDK\\Board\\MCBSTM32F400</b>)

\note SockServer for embedded system requires Arm MDK and Arm MDK Middleware Network component

The following services are available by SockServer:
- \b Echo service on port \token{7}, TCP and UDP
  \n (two instances of TCP service, one instance of UDP service)
- \b Discard service on port \token{9}, TCP and UDP
  \n (one instance of TCP service, one instance of UDP service)
- \b Chargen service on port \token{19}, TCP and UDP
  \n (two instances of TCP service, one instance of UDP service)
- \b Assistant service on port \token{5000}
  \n (helper service used to test WiFi sockets in server mode (socket accept functionality))
- \b Telnet service on port \token{23}
  \n (SockServer status monitoring service)

\note Telnet service is only available on SockServer for embedded system

\section sockserver_pc SockServer for PC running Microsoft Windows

\b Requirements:
 - Personal Computer running Microsoft Windows
 - PC connection to local network

SockServer is already built and can be executed by running the SockServer.exe file in <b>.\\Tools\\SockServer\\PC\\Win</b>

If there is an need to change anything of the functionality of the SockServer the source files are available 
in <b>.\\Tools\\SockServer\\PC\\Win</b> together with batch script used for building the executable.

\note SockServer build process requires Minimalist GNU for Windows (MinGW).

\note To build SockServer executable for PC with Microsoft Windows follow the steps below:
\note - Download and install MinGW from official web page https://osdn.net/projects/mingw/releases/
\note - Set environment path in Microsoft Windows as explained under Environment Settings heading on http://www.mingw.org/wiki/Getting_Started
\note - Run Microsoft Windows batch script <b>Build.bat</b> located in <b>.\\Tools\\SockServer\\PC\\Win</b>
\note - Built executable is located in <b>.\\Tools\\SockServer\\PC\\Win</b>

\subsection sockserver_pc_win_troubleshooting SockServer on Microsoft Windows troubleshooting

Problems and solutions:
 1. SockServer not responding to ping
    - Open Windows firewall -> Advanced security
      - select inbound rules, enable rule
        File and Printer sharing (Echo request - ICMPv4-In)
      
    - If rule does not exist, create new custom rule (New Rule...)
      - Rule type:     Custom
      - Program:       All programs
      - Protocol type: ICMPv4
      - ICMP Settings: Customize - Specific ICMP types: Echo Request
      - Scope:         Any IP address
      - Action:        Allow the connection
      - Profile:       Domain, Private (Public not advised)
      - Name:          Ping Echo  
 2. SockServer on multiple embedded systems on the same local network
    - Set unique ETH0_MAC_ADDR in Net_Config_ETH0.h for each embedded system in embedded system project


\section sockserver_embedded SockServer for embedded microcontrollers

\b Requirements:
 - Keil MCB4300 or Keil MCBSTM32F400 evaluation board
 - wired Ethernet connection to local network

\subsection sockserver_embedded_telnet Using telnet service

Telnet service provides information about received and sent data. This can help resolve driver problems when Wifi 
socket sending and receiving does not work well. For example, when the transfer test fails, you don't know if the 
\b SocketSend or \b SocketRecv functions have failed or both.

For the telnet connection from PC, at the command prompt, type the following command or use another telnet client application.
\code
c:\>telnet sockserver
\endcode

The initial page opens:
  \image html SockServer.png "Initial telnet connection"

You can view the remote IP address, port number, receiving and transmitting counters with the \b stat command:
  \image html SockMonitor.png "Status monitoring"

Status monitor constantly updates the SockServer status on the screen. To stop the screen update, press any
telnet client key.


\subsection sockserver_embedded_porting Porting SockServer to different microcontroller

Currently, the \b SockServer application is available for the \b MCB4300 and \b MCBSTM32F400 evaluation boards. 
To create SockServer application for a different microcontroller, follow the steps below:
-# Create new network project in uVision
-# Select and configure the RTE Components:
 - \b Network:Core and configure the host name and pool size in \b Net_Config.c
\code
#define NET_HOST_NAME               "SockServer"
#define NET_MEM_POOL_SIZE           16384
\endcode
 - \b Network:Interface:Ethernet and configure the MAC address in \b Net_Config_ETH0.h to avoid collisions
\code
#define ETH0_MAC_ADDR               "1E-30-6C-A2-45-5A"
\endcode
 - \b Network:Socket:BSD and configure number of sockets in \b Net_Config_BSD.h
\code
#define BSD_NUM_SOCKS               8
#define BSD_SERVER_SOCKS            4
\endcode
 - \b Network:Socket:TCP and configure number of sockets in \b Net_Config_TCP.h
\code
#define TCP_NUM_SOCKS               9
\endcode
 - \b Network:Socket:UDP and configure number of sockets in \b Net_Config_UDP.h
\code
#define UDP_NUM_SOCKS               10
\endcode
 - \b Network:Service:Telnet server and disable authentication in \b Net_Config_Telnet_Server.h
\code
#define TELNET_SERVER_AUTH_ENABLE   0
\endcode
 - \b CMSIS \b Driver:Ethernet/MAC/PHY(API) depending on your hardware
-# Configure device specific hardware:
 - Configure the CMSIS Ethernet driver and other device specific components (clock system, I/O, ...)
   as required. Please consult your device's/board's documentation for more information.
-# Copy \b SockServer.c and \b SockServer.h files and add the first to the project
-# Copy \b Telnet_Server_UIF.c and add it to the project
-# Add the code to start the services in \b main.c
\code
// Application main thread
static void app_main (void *argument) {
 
  netInitialize ();
  osDelay (500);
 
  osThreadNew(DgramServer,   NULL, NULL);
  osThreadNew(StreamServer,  NULL, NULL);
  osThreadNew(TestAssistant, NULL, NULL);
}
\endcode
-# Increase default RTX stack size to 400 bytes in \b RTX_Config.h
\code
#define OS_STACK_SIZE           400
\endcode
-# Set default global stack to 1024 bytes and heap to 6144 bytes in \b startup \b file
\code
Stack_Size      EQU     0x00000400
Heap_Size       EQU     0x00001800
\endcode

*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\defgroup wifi_sock_testing WiFi Socket testing
\ingroup wifi_funcs

Due to limitations of WiFi modules and their Software Development Kits (SDK) and software stacks often it is not possible 
to comply with CMSIS-Driver BSD rules regarding function behavior or function return codes, because of that WiFi Driver 
tests accept alternative error codes and report them as Warnings and considers certain error codes as acceptable for certain 
functions.
Exceptions to BSD-strict error codes and functionality are written below: 

WiFi socket deviations to BSD-strict functionality
==================================================

-# \b SocketBind
 - bind socket to same address again<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_EINVAL<br>non BSD-strict accepted return codes: \token{0} or \token{ARM_SOCKET_ERROR}

 - bind another socket to used address<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_EADDRINUSE<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

 - bind on closed socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ESOCK<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

-# \b SocketListen
 - listen on already listening socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_EINVAL<br>non BSD-strict accepted return codes: \token{0} or \token{ARM_SOCKET_ERROR}

 - listen on unbound socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_EINVAL<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

 - listen on closed socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ESOCK<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

 - listen on datagram socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ENOTSUP<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

-# \b SocketAccept
 - receive on disconnected socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ECONNRESET<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

 - accept on closed socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ESOCK<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

 - listen on datagram socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ENOTSUP<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

 - accept on datagram socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ENOTSUP<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

-# \b SocketConnect
 - connect socket to same address again<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_EISCONN<br>non BSD-strict accepted return codes: \token{0} or \token{ARM_SOCKET_ERROR}

 - bind on connected socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_EISCONN<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

 - connect on closed socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ESOCK<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

 - connect to non-existent port<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ECONNREFUSED<br>non BSD-strict accepted return codes: \token{ARM_SOCKET_ETIMEDOUT} or \token{ARM_SOCKET_ERROR}

 - connect to non-existent stream server<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ETIMEDOUT<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

 - connect on listening socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_EINVAL<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

 - connect datagram socket to unspecified address (0.0.0.0)<br>
   <b>BSD-strict</b> expected return code \b 0<br>non BSD-strict accepted return codes: \token{ARM_SOCKET_EINVAL} or \token{ARM_SOCKET_ERROR}
   (special case that deletes the socket destination & filtering address)

-# \b SocketRecv
 - recv on closed socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ESOCK<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

 - recv on created socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ENOTCONN<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

 - recv on bound socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ENOTCONN<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

 - recv on listening socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ENOTCONN<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

-# \b SocketRecvFrom
 - recvfrom on closed socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ESOCK<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

-# \b SocketSend
 - send on closed socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ESOCK<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

 - send on disconnected socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ECONNRESET<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

 - send on created socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ENOTCONN<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

 - send on bound socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ENOTCONN<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

 - send on listening socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ENOTCONN<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

 - send on closed socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ECONNRESET<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

-# \b SocketSendTo
 - sendto on closed socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ESOCK<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

-# \b SocketGetSockName
 - getsockname on closed socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ESOCK<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

 - getsockname on unbound socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_EINVAL<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

-# \b SocketGetPeerName
 - getpeername on closed socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ESOCK<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

 - getpeername on created socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ENOTCONN<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

 - getpeername on bound socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ENOTCONN<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

 - getpeername on listening socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ENOTCONN<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

-# \b SocketGetOpt
 - getsockopt on closed socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ESOCK<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

-# \b SocketSetOpt
 - setsockopt on closed socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ESOCK<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}

-# \b SocketClose
 - close already closed socket<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_ESOCK<br>non BSD-strict accepted return code \token{0}

-# \b SocketGetHostByName
 - gethostbyname for non-existing host<br>
   <b>BSD-strict</b> expected return code \b ARM_SOCKET_EHOSTNOTFOUND<br>non BSD-strict accepted return code \token{ARM_SOCKET_ERROR}
*/
